Distributed Algorithms Project 

Students: Jessica Pollard and Matthew Pham
Topic: snapshots
Programming Language: Odin

Overview:
This project involved the creation of a basic multiplayer game that can be saved at any point by the host inspired by Mattern's snapshot algorithm.

Structure:
- connect contains the main.odin game file which contains all logic surrounding the game mechanics and snapshot loading / saving
- connect also contains the game_packet.odin file which defines the UDP based network layer of the program 
- server contains the server code that can be ran on a dedicated pc to act as a matchmaking server
- shared contains the networking protocol used to communicate to the matchmaking server
- map.png, Fences.png, actions.png and Spritesheet.png are textures needed by the connect program
- raylib.dll is also need by the connect program for graphics 

Running the program:
The program can be run using the following commands from the root directory of the project (where client.exe is located):

1. start the host `./connect <port> <lobby id> Host`
2. in another terminal add a player `./connect <port> <lobby id> Join` -> up to 3 other players can join the host's lobby

Running the program from a save file:
The program can be ran with an existing save file, however it must have the same number of players as were in the saved lobby.

1. start the host `./connect <port> <lobby id> Host SAVE`
2. in another terminal add a player `./connect <port> <lobby id> Join` -> up to 3 other players can join the host's lobby

Game controls:
- 'w' -> move up
- 'a' -> move left
- 's' -> move down
- 'd' -> move right
- hold 'q' to carry a fence, release to place fence
- 'e' -> attack
- 'p' -> on the host this will trigger the snapshot algorithm and save the game

Functions related to snapshot algorithm:

(Note that none of the data initialising or cleanup functions are listed for the sake of brevity)

# Loading Snapshot
--------------------------------------------------------------------------------------------
  load_network()
    Loads and distributes a game save to all processes in the network
    Only the host of the network can call this function

  wait_for_load_save() 
    Waits to receive a partial save from the host of the network
--------------------------------------------------------------------------------------------

# Starting and Saving Snapshot
--------------------------------------------------------------------------------------------
  game_save_start()
    Starts the snapshot algorithm    
    Only the host of the network can call this function 

  game_save_is_complete()
    Indicates whether or not all partial snapshots have been compiled on the host's client

  game_save_complete()
    Compiles and generated a game save using partial saves generated by all participating
      processes in the network 
    Only the host of the network can call this function 

  should_snapshot()
    Indicates whether or not a snapshot should be taken by the calling client

  take_state_snapshot()
    Takes a snapshot of the client's game state

  partial_snapshot_ready()
    Indicates whether or not a partial snapshot can be compiled by the calling client

  partial_snapshot_create_and_send()
    Forms partial snapshot from previously recorded game state and buffered messages
--------------------------------------------------------------------------------------------

# Snapshot detection and termination
--------------------------------------------------------------------------------------------
  poll_for_packets()
    Processes any packets received by the network socket

  deal_with_packet()
    Handles snapshot detection, distribution and termination

  first_marker()
    Handles the detection of the first marker message received by a process

  another_marker()
    Handles the detection of all other marker messages received by a process

  deal_with_message()
    Handles the buffering of messages into a channel's recorded messages buffer

  deal_with_internal() 
    Handles updating channel state as related to recording messages
--------------------------------------------------------------------------------------------

# Functions related to the UDP reliability layer:
--------------------------------------------------------------------------------------------
  get_ack_bits()
    Retrieves a bit_set of acknowledgements where the nth bit indicates the packet with 
      (header.ack - n) sequence number was received

  send_data_to_channel()
    Sends packet to a channel. Can also simulate packet loss

  resend_data_to_channel()
    Resends a potentially lost packet to a channel using the channel's sequence buffer

  broadcast_data()
    Broadcasts data to all processes in the network

  broadcast_message()
    Broadcasts a game message to all processes in the network

  deal_with_message()
    Handles the buffering of messages into a channels unprocessed messages buffer

  deal_with_internal()
    Handles the updating of channel state as related to the unprocessed messages buffer

  get_messages()
    Retrieves the unprocessed messages buffered by the network during the current game tick

  acknowledge()
    Marks a packet as received by the recipient of the channel, doing memory cleanup

  put_message()
    Puts a message inside a channel's sequence buffer

  put_buf_recv()
    Puts an acknowledgement into the channel's receive sequence buffer
--------------------------------------------------------------------------------------------